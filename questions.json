[
  { "text": "Az operációs rendszer fő célja, hogy a felhasználó zökkenőmentesen futtathassa a saját programját.", "answer": true },
  { "text": "Az operációs rendszer nem közvetlenül kommunikál a hardverrel, hanem mindig a felhasználói programokon keresztül.", "answer": false },
  { "text": "Az operációs rendszerek felépítése tipikusan réteges szerkezetű.", "answer": true },
  { "text": "A kernel a felhasználó által közvetlenül vezérelhető, jól látható része az operációs rendszernek.", "answer": false },
  { "text": "A monolitikus kernel egyetlen nagy program, amely tartalmazza a rendszermag összes funkcióját.", "answer": true },
  { "text": "A mikrokernelek minden funkciót a kernel módban futtatnak.", "answer": false },
  { "text": "A mikrokernelek előnye, hogy a felhasználói programhibák nem veszélyeztetik a rendszer stabilitását.", "answer": true },
  { "text": "A mikrokernel architektúra minden esetben gyorsabb, mint a monolitikus kernel.", "answer": false },
  { "text": "A hibrid kernelek ötvözik a mikro- és monolitikus kernel megoldásait.", "answer": true },
  { "text": "Az exokernel nem tartalmaz absztrakciókat, csak hardverközeli hozzáférést biztosít.", "answer": true },
  { "text": "Az időosztásos rendszerek nem támogatják a többfelhasználós működést.", "answer": false },
  { "text": "Az időosztásos rendszerek lehetővé teszik, hogy a felhasználók úgy érezzék, mintha saját gépen dolgoznának.", "answer": true },
  { "text": "A multiprogramozás egy program teljes lefutása után indítja a következő programot.", "answer": false },
  { "text": "Az operációs rendszerek komponensei között megtalálható a folyamatkezelő és a központi tárkezelő is.", "answer": true },
  { "text": "A kernel ütemezője egyedül a monolitikus rendszerekben található meg.", "answer": false },
  { "text": "A folyamat (process) a számítási feladatok végrehajtásának alapegysége.", "answer": true },
  { "text": "A multiprogramozott rendszerekben egy időben csak egy folyamat lehet futó állapotban.", "answer": false },
  { "text": "A futásra kész folyamat már minden erőforrást birtokol, kivéve a CPU-t.", "answer": true },
  { "text": "A PCB tárolja a folyamat aktuális állapotát, regisztereit és memóriainformációit.", "answer": true },
  { "text": "A programszámláló a következő végrehajtandó utasítás címét tartalmazza.", "answer": true },
  { "text": "Az NMI megszakítás maszkolható, így átmenetileg letiltható.", "answer": false },
  { "text": "A CPU-ütemezési információ a folyamat prioritását és jogosultságait is tartalmazza.", "answer": true },
  { "text": "A megszakítások mindig várakoztathatók, nincs olyan, amit azonnal végre kell hajtani.", "answer": false },
  { "text": "A szál a folyamat teljes állapotát tárolja, így önállóan ütemezhető.", "answer": false },
  { "text": "A folyamat szálainak közös a virtuális memória címtartománya.", "answer": true },
  { "text": "A Windows NT szálai két veremtárral rendelkeznek: egy kernel módú és egy user módú.", "answer": true },
  { "text": "A szálak nem tartalmazhatnak regisztereket, csak a verem területet.", "answer": false },
  { "text": "A megszakítások nem okozhatnak szinkronizációs problémákat.", "answer": false },
  { "text": "A szál egyedi azonosítóval (Thread ID) rendelkezik.", "answer": true },
  { "text": "A folyamatok közötti kommunikációhoz csak közös memória használható.", "answer": false },
  { "text": "A multiprogramozott rendszerek képesek több folyamatot egyidőben futtatni, a processzorok számától függően.", "answer": true },
  { "text": "A folyamatok ütemezésére nincs szükség, ha mindig csak egy folyamat fut.", "answer": false },
  { "text": "A kritikus szakaszok nem okozhatnak megszakítást vagy kivételt.", "answer": true },
  { "text": "A környezetváltás során a megszakítási szint (IRQL) mindig változik.", "answer": false },
  { "text": "A szálak gyorsabbak a folyamatoknál, mert kevesebb információt tárolnak magukról.", "answer": true },
  { "text": "Az FCFS algoritmus preemptív működésű.", "answer": false },
  { "text": "Az RR (Round-Robin) algoritmus preemptív ütemezésű.", "answer": true },
  { "text": "A prioritásos ütemezés során a legmagasabb prioritású folyamat kap CPU-t.", "answer": true },
  { "text": "Az SJF (Shortest Job First) algoritmus nem preemptív.", "answer": true },
  { "text": "Az SRTF (Shortest Remaining Time First) algoritmus a preemptív SJF változata.", "answer": true },
  { "text": "A HRR algoritmus nem használ öregítést a kiéheztetés elkerülésére.", "answer": false },
  { "text": "Az időosztásos rendszerekben a kvantumidő hossza befolyásolja a válaszidőt.", "answer": true },
  { "text": "Az aszimmetrikus ütemezésnél minden CPU mag futtat saját ütemezőt.", "answer": false },
  { "text": "A szimmetrikus ütemezésben egyetlen CPU mag végzi a döntést, a többiek nem ütemeznek.", "answer": false },
  { "text": "A CPU kihasználtság azt mutatja meg, hogy a CPU idejének hány százalékában dolgozik folyamatokon.", "answer": true },
  { "text": "A körülfordulási idő (Turnaround Time) a munka teljes futási idejét mutatja.", "answer": true },
  { "text": "A várakozási idő (Waiting Time) a CPU által végzett tényleges futási időt mutatja.", "answer": false },
  { "text": "A válaszidő (Response Time) azt jelzi, milyen gyorsan reagál az OS a felhasználói igényekre.", "answer": true },
  { "text": "A HRR algoritmus az SJF egy változata, amely figyelembe veszi a várakozási időt is.", "answer": true },
  { "text": "A többszintű várakozási sorok (SMQ) nem mentesek a kiéheztetéstől.", "answer": true },
  { "text": "A visszacsatolt többszintű sorok (MFQ) esetében a folyamatok képesek egyik sorból a másikba átlépni.", "answer": true },
  { "text": "Az MFQ algoritmus a kiéheztetés elkerülésére nem nyújt megoldást.", "answer": false },
  { "text": "Az időosztásos rendszerekben minden folyamat egy teljes kvantumot kap, mielőtt kontextusváltás történne.", "answer": true },
  { "text": "Az NT rendszerben az ütemező mindig csak az első három prioritási szinttel dolgozik.", "answer": false },
  { "text": "A prioritási szintek fixek, az OS nem módosíthatja őket.", "answer": false },
  { "text": "Az NT rendszerben a kvantumidő minden szál esetében azonos hosszúságú.", "answer": false },
  { "text": "A CPU ütemező a kernel része, és állandóan a memóriában van.", "answer": true },
  { "text": "A szálak közötti váltás csak a preemptív rendszerekre jellemző.", "answer": false },
  { "text": "Az ütemezést kiváltó esemény lehet egy folyamat befejeződése, egy várakozási igény vagy egy időzítő megszakítás.", "answer": true },
  { "text": "Az RR algoritmus jellemzője a konvoj hatás, mivel a hosszú folyamatok hátráltatják a rövideket.", "answer": false },
  { "text": "A szálak önálló folyamatok, amelyek külön memóriaterületen futnak.", "answer": false },
  { "text": "Minden szálnak van saját utasításszámlálója és regiszterkészlete.", "answer": true },
  { "text": "A szálak öröklik a folyamat által lefoglalt erőforrásokat.", "answer": true },
  { "text": "Egy szálhoz tartozik saját veremtár.", "answer": true },
  { "text": "A kritikus szakaszban több folyamat is tartózkodhat egyszerre.", "answer": false },
  { "text": "A kritikus szakaszban nem okozhat megszakítást vagy kivételt a folyamat.", "answer": true },
  { "text": "Az aszimmetrikus kommunikációban a küldő és fogadó fél portot használ.", "answer": true },
  { "text": "A kliens-szerver modell a vevő oldali portot használja a kommunikációhoz.", "answer": true },
  { "text": "A farmer-worker modell a fogadó oldali portot használja a kommunikációhoz.", "answer": false },
  { "text": "A PRAM modellben egy memóriarekesz egyszerre több folyamat által is elérhető.", "answer": true },
  { "text": "Az olvasás-olvasás ütközés problémát okozhat a PRAM modellben.", "answer": false },
  { "text": "A szálak közötti kommunikáció minden esetben üzenetküldésen alapul.", "answer": false },
  { "text": "A versengő folyamatok csak akkor ismerik egymást, ha közös erőforrást használnak.", "answer": true },
  { "text": "A közös memória kommunikáció esetében a kommunikációt az OS biztosítja.", "answer": true },
  { "text": "A csoportkommunikáció során az üzenetet a csoport minden tagja megkapja.", "answer": true },
  { "text": "A szálak és folyamatok között a fő különbség az ütemezési stratégia.", "answer": false },
  { "text": "A szálak közös virtuális memóriateret használnak a folyamathoz.", "answer": true },
  { "text": "A PRAM modell nem támogat párhuzamos írási műveleteket.", "answer": false },
  { "text": "A küldő oldali portnál a Send művelet címzés nélkül is végrehajtható.", "answer": true },
  { "text": "Az aszimmetrikus kommunikáció mindig gyorsabb, mint a szimmetrikus.", "answer": false },
  { "text": "Az együttműködő folyamatok közös célt hajtanak végre.", "answer": true },
  { "text": "A PRAM modell rekeszenként címzést használ.", "answer": true },
  { "text": "Az aszimmetrikus kommunikációban mindig meg kell adni a fogadó folyamat azonosítóját.", "answer": false },
  { "text": "A közös memória modellhez nem szükséges külön szinkronizációs mechanizmus.", "answer": false },
  { "text": "A szálak gyorsabban váltanak egymás között, mint a folyamatok.", "answer": true },
  { "text": "A kritikus szakaszban egyszerre csak egy folyamat tartózkodhat.", "answer": true },
  { "text": "A szoftveres szinkronizáció gyorsabb, mint a hardveres megoldás.", "answer": false },
  { "text": "A kritikus szakasz elejét és végét az operációs rendszernek kell ismernie.", "answer": true },
  { "text": "A TestAndSet művelet segítségével biztosítható a kölcsönös kizárás.", "answer": true },
  { "text": "A Swap algoritmus kulcs változókkal és lakat logikai változóval dolgozik.", "answer": true },
  { "text": "A monitor programozási szerkezetben minden kritikus erőforráshoz külön eljárás tartozik.", "answer": true },
  { "text": "A monitor szerkezete nem igényel feltételváltozót.", "answer": false },
  { "text": "A monitor objektum tartalmazhat osztott adatot és eljárásokat is.", "answer": true },
  { "text": "A szemaforok egyszerre csak egy kritikus szakaszhoz használhatóak.", "answer": false },
  { "text": "Az éheztetés kizárólag hardveres hibák miatt alakulhat ki.", "answer": false },
  { "text": "A holtpont négy feltétele közül a kölcsönös kizárás mindig fennáll, ha nem megosztható erőforrásokról van szó.", "answer": true },
  { "text": "A foglalás és várakozás feltétele teljesen kiiktatható a megfelelő algoritmusokkal.", "answer": true },
  { "text": "A holtpont egy olyan állapot, amikor egyetlen folyamat sem tud előrehaladni.", "answer": true },
  { "text": "A holtpont nem okoz rendszerleállást, csak az adott folyamatok blokkolódnak.", "answer": false },
  { "text": "Az erőforrás-gráfban a hurok megléte a holtpont biztos jele.", "answer": true },
  { "text": "A preemptív erőforrások esetében a holtpont nem alakulhat ki.", "answer": false },
  { "text": "Az erőforrások kiosztásakor az operációs rendszernek ismernie kell a maximális igényeket.", "answer": true },
  { "text": "A Bankár algoritmus célja a holtpont feloldása utólagos folyamatleállítással.", "answer": false },
  { "text": "A Bankár algoritmus csak akkor biztosítja a holtpont elkerülését, ha a rendszer biztonságos állapotban van.", "answer": true },
  { "text": "A hierarchikus erőforrás-számozás megakadályozza a körkörös várakozást.", "answer": true },
  { "text": "A hierarchikus sorszám kijelölés rugalmas és minden környezetben jól működik.", "answer": false },
  { "text": "Az éheztetés olyan probléma, amikor egy folyamat akár a végtelenségig is várakozhat erőforrásra.", "answer": true },
  { "text": "Az éheztetés megoldható öregítés (aging) technikával.", "answer": true },
  { "text": "A nem preemptív erőforrásokat bármikor elvehetjük a folyamatoktól.", "answer": false },
  { "text": "A holtpont megelőzésére szolgáló módszerek nem minden esetben költséghatékonyak.", "answer": true },
  { "text": "Az operációs rendszer képes a holtpont automatikus felismerésére minden esetben.", "answer": false },
  { "text": "Ha a rendszer nem tartalmaz hurkot, akkor biztosan holtpontmentes.", "answer": true },
  { "text": "Az erőforrás foglalása után azonnal megszűnik a várakozás.", "answer": false },
  { "text": "Az éheztetés kialakulásának lehetősége a holtpont kezelésétől független.", "answer": true },
  { "text": "A holtpont mindig detektálható a megfelelő algoritmusok segítségével.", "answer": false },
  { "text": "A holtpont megszüntetése veszteségmentesen megoldható.", "answer": false },
  { "text": "Az erőforrás-gráf minden hurokja holtpontot jelez.", "answer": false },
  { "text": "A foglalás és várakozás együttes feltétele elegendő a holtpont kialakulásához.", "answer": false },
  { "text": "Az egypéldányos erőforrások mindig kizárólagos használatot igényelnek.", "answer": true },
  { "text": "A holtpont kezelése helyett gyakran hatékonyabb a megelőzése.", "answer": true },
  { "text": "A lapozás fix méretű memóriablokkokkal dolgozik.", "answer": true },
  { "text": "A szegmensszervezés jellemzően rögzített méretű blokkokkal dolgozik.", "answer": false },
  { "text": "A lapszervezésnél a belső tördelődés a kihasználatlan területek miatt alakul ki.", "answer": true },
  { "text": "A szegmensszervezésnél a külső tördelődés problémája jelentkezik.", "answer": true },
  { "text": "A kombinált szervezés a lapozás és a szegmensszervezés előnyeit ötvözi.", "answer": true },
  { "text": "A logikai cím két komponensből áll: szegmens/lapazonosító és eltolás.", "answer": true },
  { "text": "A laphiba akkor fordul elő, ha egy program olyan memórialapot hivatkozik meg, amely nincs a RAM-ban.", "answer": true },
  { "text": "Az igény szerinti lapozás során minden szükséges lapot előre betölt a rendszer.", "answer": false },
  { "text": "Az előretekintő lapozás (pre-fetch) segíthet csökkenteni a laphibák számát.", "answer": true },
  { "text": "Az optimális lapcsere algoritmus a jövőbeni hivatkozások ismeretében választja ki a lecserélendő lapot.", "answer": true },
  { "text": "Az LRU algoritmus a legutoljára használt lapokat tartja a memóriában.", "answer": true },
  { "text": "A FIFO algoritmus a legrégebbi lapot cseréli le.", "answer": true },
  { "text": "Az LFU algoritmus a legritkábban használt lapokat cseréli le.", "answer": true },
  { "text": "A Second Chance algoritmus a laphoz tartozó „referencia bitet” is figyelembe veszi.", "answer": true },
  { "text": "A page table (laptábla) tartalmazza a logikai címekhez tartozó fizikai címeket.", "answer": true },
  { "text": "A TLB (Translation Lookaside Buffer) a laphibák számát növeli.", "answer": false },
  { "text": "A TLB gyorsítótár a legutóbb használt címleképezések gyors eléréséhez.", "answer": true },
  { "text": "A virtuális memória fogalma azt jelenti, hogy a program nagyobb címteret lát, mint a fizikai memória mérete.", "answer": true },
  { "text": "A belső tördelődés csak a szegmensszervezésnél jelentkezik.", "answer": false },
  { "text": "Az operációs rendszer automatikusan oldja meg a logikai és fizikai címek közötti átalakítást.", "answer": true },
  { "text": "A lapcsere algoritmusok célja, hogy minimalizálják a laphibák számát.", "answer": true },
  { "text": "A ReadyBoost technológia a memóriakezelést támogatja USB eszközök segítségével.", "answer": true },
  { "text": "A Copy-on-Write mechanizmus célja a memóriahatékonyság növelése.", "answer": true },
  { "text": "A kernel memória területe sosem lehet lapozott.", "answer": false },
  { "text": "A rendszer cache nem befolyásolja a memóriakezelési döntéseket.", "answer": false },
  { "text": "Az IA-64 architektúra támogatja a 64 bites címtartományokat.", "answer": true },
  { "text": "A szabad memória mindig azonnal elérhető a folyamatok számára.", "answer": false },
  { "text": "A logikai és fizikai címek mindig megegyeznek.", "answer": false },
  { "text": "A Superfetch a gyakran használt adatokat előre betölti a memóriába.", "answer": true },
  { "text": "A PAE (Physical Address Extension) segítségével 32 bites rendszerek is kezelhetnek 64 GB memóriát.", "answer": true },
  { "text": "A fájl logikai információk gyűjteménye, amelyet egyedileg azonosíthatunk a fájlnév segítségével.", "answer": true },
  { "text": "Az állománykezelő rendszer nem része az operációs rendszernek, hanem különálló alkalmazás.", "answer": false },
  { "text": "A fájlrendszer lehetővé teszi a felhasználó számára a fizikai tárolók elérését megfelelő jogosultságokkal.", "answer": true },
  { "text": "A könyvtárak csak fájlokat tartalmazhatnak, más könyvtárat nem.", "answer": false },
  { "text": "A könyvtár bejegyzései tartalmazhatják a fájlok nevét, típusát és hozzáférési jogait.", "answer": true },
  { "text": "A könyvtár bejegyzései tartalmazzák a fájl tartalmát is.", "answer": false },
  { "text": "A soros hozzáférés azt jelenti, hogy csak a fájl elejétől lehet olvasni.", "answer": true },
  { "text": "A közvetlen elérés esetében meg kell adni a fájlon belüli cím sorszámát.", "answer": true },
  { "text": "Az index-szekvenciális elérés lehetővé teszi a gyors keresést a rekordok között.", "answer": true },
  { "text": "Az index-szekvenciális elérésnél nincs szükség indexállományokra.", "answer": false },
  { "text": "A láncolt tárolás előnye, hogy nem igényel folyamatos lemezterületet.", "answer": true },
  { "text": "Az indexelt tárolás során minden fájlhoz csak egy indexblokk szükséges.", "answer": false },
  { "text": "Az indexelt tárolás előnye, hogy a blokkok közvetlenül elérhetők.", "answer": true },
  { "text": "Az indexelt tárolásnál a kis fájlok esetében nincs pazarlás.", "answer": false },
  { "text": "A szabad helyek kezelése megoldható bittérképes ábrázolással.", "answer": true },
  { "text": "A bittérképes megoldás előnye, hogy könnyen kijelölhetők az egymás melletti szabad blokkok.", "answer": true },
  { "text": "A láncolt listás megoldás nem igényel plusz tárterületet a szabad blokkok követéséhez.", "answer": false },
  { "text": "A szabad blokkok csoportos láncolása gyorsabb, mint az egyes blokkok láncolása.", "answer": true },
  { "text": "Az egybefüggő szabad területek leírása hatékony megoldás a lemezterület kezelésére.", "answer": true },
  { "text": "Az FAT tábla nem tartalmaz információt a szabad blokkokról.", "answer": false },
  { "text": "Az FAT tábla segítségével a szabad és a foglalt blokkok is nyilvántarthatók.", "answer": true },
  { "text": "Az FAT tábla csak egy példányban tárolódik a lemezen.", "answer": false },
  { "text": "Az NTFS rendszer támogatja a fájlok jogosultságkezelését és a titkosítást.", "answer": true },
  { "text": "Az NTFS támogatja a fájlok tömörítését.", "answer": true },
  { "text": "Az NTFS rendszer nem alkalmas nagy méretű lemezek kezelésére.", "answer": false },
  { "text": "Az állományokhoz rendelt attribútumok nem változtathatók meg a fájl tartalmának módosítása nélkül.", "answer": false },
  { "text": "A fájl megnyitása során ellenőrzik a jogosultságokat.", "answer": true },
  { "text": "A fájlhoz tartozó blokkok fizikai címeit a könyvtár bejegyzésében tárolják.", "answer": false },
  { "text": "A hozzáírás művelete növeli a fájl méretét.", "answer": true },
  { "text": "Az állomány törlése során a foglalt blokkok automatikusan felszabadulnak.", "answer": true },
  { "text": "A könyvtárstruktúrák lehetnek fa és gráf alapúak.", "answer": true },
  { "text": "A könyvtárak hierarchikus szerveződése lehetővé teszi az alárendelt könyvtárak létrehozását.", "answer": true },
  { "text": "Az operációs rendszer minden fájlt külön folyamatként kezel.", "answer": false },
  { "text": "Az attribútumok között lehet módosítási idő, jogosultság, tulajdonos is.", "answer": true },
  { "text": "A fájlrendszerek nem tárolnak információt a fájlok típusáról.", "answer": false },
  { "text": "A fájlok és könyvtárak jogai csak a tulajdonos által módosíthatók.", "answer": false },
  { "text": "Az I/O alrendszer szolgáltatásait a fájlkezelő rendszer is használja.", "answer": true },
  { "text": "A könyvtárak kizárólag a merevlemezen tárolhatók, nem lehetnek más típusú háttértáron.", "answer": false },
  { "text": "A dinamikus helygazdálkodás célja a hatékony tárhasználat.", "answer": true },
  { "text": "A fájlok blokkjainak logikai összefűzése nem szükséges a láncolt tárolásban.", "answer": false },
  { "text": "A perifériák a számítógép beágyazott részei, a CPU részei.", "answer": false },
  { "text": "A Human Interface Devices (HID) kategóriába tartozik a billentyűzet, egér és monitor.", "answer": true },
  { "text": "A LAN és WLAN a gép-gép kapcsolattartás perifériái közé tartoznak.", "answer": true },
  { "text": "Az USB egy soros csatlakozási szabvány.", "answer": true },
  { "text": "A vezérlőegység a periféria része, amely közvetlenül vezérli az eszköz működését.", "answer": true },
  { "text": "A perifériák működési sebessége jellemzően gyorsabb, mint a CPU-é.", "answer": false },
  { "text": "Az operációs rendszernek nem kell foglalkoznia a perifériákkal, azokat a BIOS kezeli.", "answer": false },
  { "text": "Az API (Application Interface) egységes felületet biztosít a perifériák kezeléséhez.", "answer": true },
  { "text": "A logikai perifériák kezelését általában eszközmeghajtók (Device Driver-ek) segítik.", "answer": true },
  { "text": "A Device Driver célja a hatékony perifériakezelés biztosítása.", "answer": true },
  { "text": "A párhuzamos perifériakezelés csökkenti a rendszer teljesítményét.", "answer": false },
  { "text": "Az I/O műveletek során az adatblokkokat a CPU és a periféria között mozgatják.", "answer": true },
  { "text": "Az IOCB (Input/Output Control Block) az I/O műveletek paramétereit tartalmazza.", "answer": true },
  { "text": "Az alacsony szintű I/O kezelés három művelete a Start, Wait és Stop.", "answer": true },
  { "text": "Az IOCB csak akkor törölhető a várakozási sorból, ha nincs aktív átvitel.", "answer": true },
  { "text": "Az I/O műveletek adatmozgatásának legfontosabb paraméterei a forrás, a cél és az adatméret.", "answer": true },
  { "text": "A logikai periféria kezeléshez nincs szükség eszközmeghajtókra.", "answer": false },
  { "text": "Az operációs rendszer csak a fizikai perifériákat kezeli, a logikai perifériákra nincs rálátása.", "answer": false },
  { "text": "Az API réteg a felhasználói programok és a perifériák közötti közvetítő.", "answer": true },
  { "text": "Az eszközmeghajtók a hardverhez közvetlenül csatlakoznak, nem igényelnek OS támogatást.", "answer": false },
  { "text": "Az IRQ (Interrupt Request) és a DMA (Direct Memory Access) a készülékkezelő rétegben használatos.", "answer": true },
  { "text": "Az adatblokkok mozgatása nem igényel szinkronizációt a CPU és a periféria között.", "answer": false },
  { "text": "Az IOCB állapotai között lehet „fut”, „várakozik” és „befejeződött”.", "answer": true },
  { "text": "Az adatátvitel irányának meghatározása az adatforrás és -cél szerepétől függ.", "answer": true },
  { "text": "A Human Interface Devices mindig valós idejű kapcsolatot igényelnek a CPU-val.", "answer": false },
  { "text": "A perifériák működése független a csatlakozási szabványtól.", "answer": false },
  { "text": "A DMA lehetővé teszi, hogy az adatátvitel a CPU közreműködése nélkül történjen.", "answer": true },
  { "text": "Az eszközmeghajtók mindig a kernel mód részei.", "answer": true },
  { "text": "A párhuzamos perifériakezelés növeli a rendszer hatékonyságát.", "answer": true },
  { "text": "A Device Interface (DI) egységes csatlakozófelületet biztosít az I/O eszközökhöz.", "answer": true },
  { "text": "Az operációs rendszer felelős a felhasználói azonosításért és a hozzáférési jogok ellenőrzéséért.", "answer": true },
  { "text": "A védelem csak szoftveres megoldásokból áll.", "answer": false },
  { "text": "A Windows NT támogatja a Unicode karakterkódolást.", "answer": true },
  { "text": "A vírusok minden esetben fájlokat fertőznek meg.", "answer": false },
  { "text": "A trójai programok nem képesek rejtőzködni más szoftverek mögött.", "answer": false },
  { "text": "Az adathalászat célja a felhasználói adatok megszerzése.", "answer": true },
  { "text": "A címhamisítás (spoofing) során az üzenet feladója valótlan információt ad meg.", "answer": true },
  { "text": "A pszichológiai manipuláció célja a felhasználó rábeszélése valamilyen tevékenységre.", "answer": true },
  { "text": "A zsarolóvírusok célja az adatok titkosítása és váltságdíj követelése.", "answer": true },
  { "text": "A biztonsági másolatok feleslegesek, ha a rendszer jól konfigurált.", "answer": false },
  { "text": "A védelmi tartomány (domain) meghatározza, hogy egy folyamat mely erőforrásokat érhet el.", "answer": true },
  { "text": "A védelmi mátrix csak statikus lehet.", "answer": false },
  { "text": "A védelem minden esetben egyetlen tényezőn múlik.", "answer": false },
  { "text": "Az elosztott rendszerekben a védelem kiterjed a hálózati kommunikációra is.", "answer": true },
  { "text": "A tűzfal képes megakadályozni minden típusú támadást.", "answer": false },
  { "text": "Az erőforrás-kezelés szerves része a jogosultságok kiosztása.", "answer": true },
  { "text": "A Microsoft célja a Windows NT esetében a könnyen továbbfejleszthető és skálázható rendszer kialakítása volt.", "answer": true },
  { "text": "A Windows NT nem képes több processzor támogatására.", "answer": false },
  { "text": "A Windows NT-n belüli folyamatok nem befolyásolhatják egymás működését.", "answer": true },
  { "text": "A Windows NT Server és Workstation verziói azonos kvantumidőket használnak.", "answer": false },
  { "text": "A Windows NT hibrid kernel architektúrával rendelkezik.", "answer": true },
  { "text": "A rendszer stabilitásának növelése érdekében a Windows NT különböző funkciókat külön rétegekbe szervez.", "answer": true },
  { "text": "Az NT rendszer prioritási szintjei teljesen statikusak, nem módosíthatók futásidőben.", "answer": false },
  { "text": "A Windows NT az API-n keresztül biztosít kompatibilitást a régebbi rendszerekkel.", "answer": true },
  { "text": "A Windows NT-n a megszakítások kezelését kizárólag a kernel végzi.", "answer": true },
  { "text": "A Microsoft operációs rendszereiben nincs lehetőség Unicode karakterek használatára.", "answer": false },
  { "text": "Az NT rendszer nem képes elosztott rendszerek működtetésére.", "answer": false },
  { "text": "A jogosultságok felhasználónként és csoportonként is definiálhatók.", "answer": true },
  { "text": "Az NT rendszer képes együttműködni különböző hardver architektúrákkal.", "answer": true },
  { "text": "A védelem és a biztonság nem igényel emberi tényezőt, csak technológiai megoldásokat.", "answer": false },
  { "text": "A Windows NT kernel architektúrája réteges szerkezetű.", "answer": true },
  { "text": "A Win32 API nem része a Windows NT rendszernek, külső fejlesztők biztosítják.", "answer": false },
  { "text": "A Windows NT támogatja a 64-bites alkalmazások futtatását natív módban.", "answer": true },
  { "text": "A WoW64 alrendszer lehetővé teszi a 32-bites programok futtatását 64-bites rendszereken.", "answer": true },
  { "text": "A Windows NT csak 64-bites rendszeren képes működni.", "answer": false },
  { "text": "Az objektumkezelő felelős a rendszer erőforrásainak egységes eléréséért.", "answer": true },
  { "text": "A Windows NT-ben minden objektumot a kernel kezel.", "answer": false },
  { "text": "Az objektumok kezelését és védelmét az executive réteg valósítja meg.", "answer": true },
  { "text": "Az objektumok elérhetőségét handle-ök segítségével biztosítják.", "answer": true },
  { "text": "A Windows NT nem támogatja a kis- és nagybetű megkülönböztetést a fájlnevekben.", "answer": false },
  { "text": "A Windows NT eseménynaplózása a felhasználói szintű folyamatokra korlátozódik.", "answer": false },
  { "text": "Az Exception Dispatcher kezeli a bekövetkező kivételeket.", "answer": true },
  { "text": "A trap kezelés során a CPU user módból kernel módba vált.", "answer": true },
  { "text": "A szálak kezelése során minden szálnak egyedi azonosítója (Thread ID) van.", "answer": true },
  { "text": "Az NT rendszerben a folyamatok nem rendelkeznek saját virtuális memória címtérrel.", "answer": false },
  { "text": "A Windows NT folyamatainak legalább egy szála van, amely elinduláskor automatikusan futni kezd.", "answer": true },
  { "text": "A Windows NT rendszerében a KTHREAD tartalmazza a szálütemezéshez kapcsolódó adatokat.", "answer": true },
  { "text": "A Win32 API függvényhívások minden esetben közvetlenül a kernelbe jutnak.", "answer": false },
  { "text": "Az NT rendszerben a szolgáltatások user módban futnak.", "answer": true },
  { "text": "Az SMSS (Session Manager) a felhasználói fiókok kezeléséért felelős.", "answer": false },
  { "text": "Az NT rendszerben a LOGON folyamat felelős a felhasználói bejelentkezésért.", "answer": true },
  { "text": "Az NT rendszerben a Service Controller indítja és felügyeli a szolgáltatásokat.", "answer": true },
  { "text": "A Windows NT alrendszerei nem kommunikálnak egymással.", "answer": false },
  { "text": "A Windows NT-ben a megszakításokat a kernel kezeli.", "answer": true },
  { "text": "A megszakítások mindig hardveres eredetűek.", "answer": false },
  { "text": "Az NT kernel architektúrája támogatja a multiprocesszoros környezetet.", "answer": true },
  { "text": "A kvantumidő minden szál esetében azonos a Windows NT Workstation és Server verziókban.", "answer": false },
  { "text": "A Windows NT kernelében található a Trap Dispatcher, amely a kivételek kezeléséért felelős.", "answer": true },
  { "text": "A Windows NT alrendszereinek működése kliens-szerver alapú.", "answer": true },
  { "text": "Az NT rendszerben az objektumkezelő nem biztosít névteret az objektumok számára.", "answer": false },
  { "text": "Az elosztott rendszerek célja többek között a párhuzamos feldolgozás és a hibatűrés biztosítása.", "answer": true },
  { "text": "Az elosztott rendszerek csak homogén (azonos típusú) hardver környezetben működhetnek.", "answer": false },
  { "text": "A konkurens működés jellemzője, hogy több folyamat is futhat egyszerre a rendszerben.", "answer": true },
  { "text": "Az átlátszóság biztosítja, hogy a felhasználó ne érzékelje az elosztott rendszer összetettségét.", "answer": true },
  { "text": "Az elosztott rendszerek nem támogathatják a redundanciát.", "answer": false },
  { "text": "A hibatűrés célja a rendszer stabilitásának fenntartása hibák esetén is.", "answer": true },
  { "text": "Az erőforráskezelő feladata a rendszer erőforrásainak megosztása és elérhetőségének biztosítása.", "answer": true },
  { "text": "A nyílt elnevezési rendszer nem teszi lehetővé a szoftveres bővítéseket.", "answer": false },
  { "text": "Az elosztott rendszerek minden esetben fix topológiával rendelkeznek.", "answer": false },
  { "text": "A virtualizáció lehetővé teszi, hogy több virtuális gép fusson egy fizikai gépen.", "answer": true },
  { "text": "A virtualizáció nem támogatja a hardver erőforrások megosztását.", "answer": false },
  { "text": "A felhő alapú rendszerek jellemzője a rugalmas erőforrás-allokáció.", "answer": true },
  { "text": "A felhőszolgáltatások típusai közé tartozik az IaaS, PaaS és SaaS.", "answer": true },
  { "text": "A mobil operációs rendszerek nem különböznek a desktop rendszerektől.", "answer": false },
  { "text": "A biztonság több tényezős megközelítést igényel: szoftveres, hardveres és emberi tényezők is fontosak.", "answer": true },
  { "text": "Az átlátszóság fogalma szerint a rendszer felhasználója számára a háttérben zajló folyamatok rejtve maradnak.", "answer": true },
  { "text": "A cloud rendszerek csak privát hálózatban működnek.", "answer": false },
  { "text": "A szoftveres frissítések nem befolyásolják a rendszer biztonságát.", "answer": false },
  { "text": "A jövőbeli rendszerek fejlődése várhatóan a mesterséges intelligencia integrációja felé halad.", "answer": true },
  { "text": "A mobil rendszerek soha nem használnak hálózati kommunikációt.", "answer": false },
  { "text": "A mobil rendszerek fejlesztése során kiemelt szempont az energiahatékonyság.", "answer": true },
  { "text": "A virtualizáció csak a szoftverek szintjén valósítható meg, hardveres támogatásra nincs szükség.", "answer": false },
  { "text": "Az elosztott rendszerek átlátszósága lehet hozzáférési, hely-, vagy hibakezelési típusú.", "answer": true },
  { "text": "A virtualizáció csökkentheti a rendszer hardver költségeit.", "answer": true },
  { "text": "A felhasználók egy elosztott rendszerben mindig pontosan ismerik a szolgáltatások helyét.", "answer": false },
  { "text": "A hibakezelés célja, hogy a rendszer hibák esetén is működőképes maradjon.", "answer": true },
  { "text": "A nyílt rendszerek jellemzője, hogy bővíthetők és heterogén hardvereket is kezelhetnek.", "answer": true },
  { "text": "A cloud rendszerekben minden felhasználó kizárólag saját gépen dolgozik.", "answer": false },
  { "text": "A konkurens működéshez nincs szükség több processzorra.", "answer": false },
  { "text": "A jövő rendszerei várhatóan egyre inkább támogatják a hibatűrést és a skálázhatóságot.", "answer": true },
  { "text": "A megszakítások és kivételek mindig hardver alapúak.", "answer": false },
  { "text": "A Windows NT alapú rendszerekben a Trap Dispatcher dönt a probléma kezeléséről.", "answer": true },
  { "text": "A Windows NT-ben a szinkronizációt főleg a Spin-Lock segítségével oldják meg.", "answer": true },
  { "text": "A Spin-Lock egy erőforrásra vonatkozó zárolási mechanizmus.", "answer": true },
  { "text": "A Windows NT rendszerben az objektumokhoz a handle biztosít hozzáférést.", "answer": true },
  { "text": "A handle egy egyedi azonosító, ami az objektumhoz való hozzáférést teszi lehetővé.", "answer": true },
  { "text": "A Windows NT rendszerek nem támogatják a nagy- és kisbetűk megkülönböztetését a fájlnevekben.", "answer": false },
  { "text": "A szálak a folyamatok részei, nem teljesen önálló egységek.", "answer": true },
  { "text": "Egy szálhoz tartozik két verem: kernel és user módú futáshoz.", "answer": true },
  { "text": "A kernel szálblokk (KTHREAD) tartalmazza a szálütemezéshez és szinkronizációhoz szükséges adatokat.", "answer": true },
  { "text": "A Windows NT-ben a folyamatok és szálak prioritásai teljesen statikusak, nem változnak futás közben.", "answer": false },
  { "text": "A CreateProcess függvény hívásával mindig egy prioritási osztályt is meg kell adni.", "answer": false },
  { "text": "A Windows NT rendszerben a kvantum időszelet lejárta után a szál futása mindig megszakad.", "answer": true },
  { "text": "A Windows NT rendszerben a prioritási szintek 0-tól 31-ig terjednek.", "answer": true },
  { "text": "A rendszer általában a legnagyobb prioritású, futásra kész szálat választja futásra.", "answer": true },
  { "text": "A Windows NT-ben a Dispatcher rutinok kizárólag IRQL 0 szinten futnak.", "answer": false },
  { "text": "A kvantum időszelet Windows NT Workstation esetén kisebb, mint Windows NT Server esetén.", "answer": true },
  { "text": "Az NT rendszer ütemezése teljesen fix, nem preemptív.", "answer": false },
  { "text": "A szál állapotai között megtalálható a Ready, Running és Waiting állapot is.", "answer": true },
  { "text": "Az átmeneti (Transition) állapot csak akkor jön létre, ha a szál veremtára kilapozódott.", "answer": true },
  { "text": "A szál létrehozása során a PspCreateThread hív meg több segédfüggvényt.", "answer": true },
  { "text": "A szálak prioritása a folyamat prioritásától teljesen független.", "answer": false },
  { "text": "A CreateProcess hívás után a kezdeti szál automatikusan elindul.", "answer": true },
  { "text": "Az LPC (Local Procedure Call) csak felhasználói folyamatok közötti kommunikációra szolgál.", "answer": false },
  { "text": "Az LPC üzenet méretétől függően puffer vagy megosztott memória is használható.", "answer": true },
  { "text": "Az Executive objektumok jellemzően több kernel objektumból épülnek fel.", "answer": true },
  { "text": "A Windows NT szinkronizációs objektumai lehetnek statikusak vagy dinamikusan kezeltek.", "answer": true },
  { "text": "A Dispatcher Object típusok célja a várakoztatás és szinkronizáció kezelése.", "answer": true },
  { "text": "A Windows NT nem támogatja a többprocesszoros ütemezést.", "answer": false },
  { "text": "A processzor affinitás azt jelenti, hogy egy szál melyik processzoron futhat.", "answer": true },
  { "text": "A Windows 10 memóriamegoszlás területén a 'Használatban' érték a folyamatok, illesztőprogramok és az operációs rendszer által használt memória mennyiségét jelzi.", "answer": true },
  { "text": "A 'Módosított' memória terület nem kerül háttértárra.", "answer": false },
  { "text": "A 'Készenléti' memória aktívan nem használt, gyorsítótárazott adatokat tartalmaz.", "answer": true },
  { "text": "A 'Szabad' memória a rendszer által elsőként újrahasznosított terület.", "answer": true },
  { "text": "A 'Gyorsítótárazott' memória teljesen kihasznált memóriaterületet jelöl.", "answer": false },
  { "text": "A PAE (Physical Address Extension) lehetővé teszi, hogy 32-bites rendszerek 64 GB memóriát kezeljenek.", "answer": true },
  { "text": "Az IA-64 architektúra kizárólag x86 processzorokhoz készült.", "answer": false },
  { "text": "A Windows NT memóriakezelője felelős a logikai és fizikai címek transzformációjáért.", "answer": true },
  { "text": "A virtuális memória telítődésekor a memóriakezelő a használt lapokat a háttértárra menti.", "answer": true },
  { "text": "A Windows NT memóriakezelője nem támogatja a Memory Mapped Files megoldást.", "answer": false },
  { "text": "A 32-bites Windows NT rendszerekben az alapértelmezett címterület 2GB az alkalmazások és 2GB az operációs rendszer számára.", "answer": true },
  { "text": "A /3GB kapcsoló használatával a Windows NT 32-bites rendszerben 3GB-1GB arányra módosítható a címterület.", "answer": true },
  { "text": "A 64-bites rendszerek címtartománya maximum 6.657GB a rendszer folyamatainak számára.", "answer": true },
  { "text": "A Superfetch technológia a memóriában lévő lapokat 8 szintű prioritással kezeli.", "answer": true },
  { "text": "A ReadyBoost technológia célja a memória bővítése USB eszközök segítségével.", "answer": false },
  { "text": "A Windows NT rendszerek memóriakezelése nem tesz különbséget a lapozott és nem lapozott memória között.", "answer": false },
  { "text": "A Copy-on-Write mechanizmus késlelteti a memória másolat elkészítését, amíg valóban szükséges nem lesz.", "answer": true },
  { "text": "A Copy-on-Write technika lusta kiértékelés elvén működik.", "answer": true },
  { "text": "A logikai memória címek mind a felhasználói, mind a kernel módú programok számára azonos elérésűek.", "answer": false },
  { "text": "Az osztott memória lehetővé teszi, hogy ugyanazt az adatot több folyamat is elérhesse.", "answer": true },
  { "text": "A szekció objektum (Section Object) az osztott memória kezelésének alapja.", "answer": true },
  { "text": "A Windows NT memóriavédelme biztosítja, hogy a folyamatok ne férhessenek hozzá más folyamat memóriaterületéhez.", "answer": true },
  { "text": "A kernel szinten futó modulok mindig elérhetők a felhasználói módú folyamatok számára.", "answer": false },
  { "text": "Az ACL (Access Control List) szabályozza, hogy mely folyamatok érhetik el az adott memóriaterületet.", "answer": true },
  { "text": "A Windows NT memóriakezelése nem engedélyezi a lapozást a kernel komponensek számára.", "answer": false },
  { "text": "A nem lapozott memória tár (NonPaged Pool) soha nem kerül a háttértárra.", "answer": true },
  { "text": "A Reserve művelet a virtuális címtartomány lefoglalását jelenti, de nem foglal tényleges fizikai memóriát.", "answer": true },
  { "text": "A Commit művelet után az alkalmazás elkezdheti használni a lefoglalt memória területet.", "answer": true },
  { "text": "A szálak user módú veremtárának foglalása során a Reserve és Commit mindig egy lépésben történik.", "answer": false },
  { "text": "A logikai címtér tartalmazza az operációs rendszer és az alkalmazások memóriatartományát is.", "answer": true }
]


